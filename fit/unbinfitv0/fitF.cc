/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...


#include "fitF.hh"


ClassImp(fitF)

fitF::fitF(const char *name, const char *title,
           RooAbsReal& _x,
           RooAbsReal *_pp[]) :
    RooAbsPdf(name,title),
    x("x","x",this,_x)
{
    for (Int_t i=0;i<MAX_N_PARMS;i++){
        p[i]=new RooRealProxy(Form("p%i",i),Form("p%i",i),this,*_pp[i]);
    }
}


fitF::fitF(const fitF& other, const char* name) :
    RooAbsPdf(other,name),
    x("x",this,other.x)
{
    for (Int_t i=0;i<MAX_N_PARMS;i++)
        p[i]=new RooRealProxy(Form("p%i",i),this,*other.p[i]);
}

#ifdef FIT_METHOD1
Double_t fitF::evaluate() const
{
    Double_t ret = 0;
    Double_t tc=*p[0];
    Double_t w=*p[1];
    Double_t dtL=*p[2];
    Double_t dtR=*p[3];
    if (x<=tc-dtL)
        ret = exp(dtL*(2*x-2*tc+dtL)/2/w/w);
    else if (x>tc-dtL&&x<tc+dtR)
        ret = exp(-(x-tc)*(x-tc)/2/w/w);
    else
        ret = exp(dtR*(-2*x+2*tc+dtR)/2/w/w);

    return ret;
}
#endif


#ifdef FIT_METHOD2
Double_t fitF::evaluate() const
{
    Double_t ret = 0;
    Double_t mu=*p[0];
    Double_t l=*p[1];
    Double_t g=*p[2];
    Double_t s=*p[3];
    return 1./sqrt(1+(x-mu)*(x-mu)/l/l) * exp(-0.5*(g+s*TMath::ASinH((x-mu)/l)) *(g+s*TMath::ASinH((x-mu)/l)));
}
#endif
